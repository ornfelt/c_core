#include <bits/stdc++.h>
#include <iostream>

/**
https://www.geeksforgeeks.org/implementation-of-vernam-cipher-or-one-time-pad-algorithm/

One Time Pad algorithm is the improvement of the Vernam Cipher, proposed by An Army Signal
Corp officer, Joseph Mauborgne. It is the only available algorithm that is
unbreakable(completely secure). It is a method of encrypting alphabetic plain text. It is
one of the Substitution techniques which converts plain text into ciphertext. In this
mechanism, we assign a number to each character of the Plain-Text.

The two requirements for the One-Time pad are

    The key should be randomly generated as long as the size of the message.
    The key is to be used to encrypt and decrypt a single message, and then it is discarded.

So encrypting every new message requires a new key of the same length as the new message
in one-time pad.

The ciphertext generated by the One-Time pad is random, so it does not have any
statistical relation with the plain text.

Security of One-Time Pad:
	If any way cryptanalyst finds these two keys using which two plaintext are produced
	but if the key was produced randomly, then the cryptanalyst cannot find which key is
	more likely than the other. In fact, for any plaintext as the size of ciphertext, a
	key exists that produces that plaintext.
	So if a cryptanalyst tries the brute force attack(try using all possible keys), he
	would end up with many legitimate plaintexts, with no way of knowing which plaintext
	is legitimate. Therefore, the code is unbreakable.
	The security of the one-time pad entirely depends on the randomness of the key. If the
	characters of the key are truly random, then the characters of the ciphertext will be
	truly random. Thus, there are no patterns or regularities that a cryptanalyst can use
	to attack the ciphertext.

Advantages:
	One-Time Pad is the only algorithm that is truly unbreakable and can be used for
	low-bandwidth channels requiring very high security(ex. for military uses).

Disadvantages
	There is the practical problem of making large quantities of random keys. Any heavily
	used system might require millions of random characters on a regular basis.
	For every message to be sent, a key of equal length is needed by both sender and
	receiver. Thus, a mammoth key distribution problem exists.

	Time Complexity: O(N)
	Space Complexity: O(N)
*/

using namespace std;
// Method 1
// Returning encrypted text
string stringEncryption(string text, string key)
{

	// Initializing cipherText
	string cipherText = "";

	// Initialize cipher array of key length
	// which stores the sum of corresponding no.'s
	// of plainText and key.
	int cipher[key.length()];

	for (int i = 0; i < key.length(); i++) {
		cipher[i] = text.at(i) - 'A' + key.at(i) - 'A';
	}

	// If the sum is greater than 25
	// subtract 26 from it
	// and store that resulting value
	for (int i = 0; i < key.length(); i++) {
		if (cipher[i] > 25) {
			cipher[i] = cipher[i] - 26;
		}
	}

	// Converting the no.'s into integers

	// Convert these integers to corresponding
	// characters and add them up to cipherText
	for (int i = 0; i < key.length(); i++) {
		int x = cipher[i] + 'A';
		cipherText += (char)x;
	}

	// Returning the cipherText
	return cipherText;
}

// Method 2
// Returning plain text
static string stringDecryption(string s, string key)
{
	// Initializing plain text
	string plainText = "";

	// Initializing integer array of key length
	// which stores difference
	// of corresponding no.'s of
	// each character of cipherText and key
	int plain[key.length()];

	// Running for loop for each character
	// subtracting and storing in the array
	for (int i = 0; i < key.length(); i++) {
		plain[i] = s.at(i) - 'A' - (key.at(i) - 'A');
	}

	// If the difference is less than 0
	// add 26 and store it in the array.
	for (int i = 0; i < key.length(); i++) {
		if (plain[i] < 0) {
			plain[i] = plain[i] + 26;
		}
	}

	// Converting int to corresponding char
	// add them up to plainText
	for (int i = 0; i < key.length(); i++) {
		int x = plain[i] + 'A';
		plainText += (char)x;
	}

	// Returning plainText
	return plainText;
}

// Method 3
// Main driver method
int main()
{
	// Declaring plain text
	string plainText = "Hello";

	// Declaring key
	string key = "MONEY";

	// Converting plain text to toUpperCase
	// function call to stringEncryption
	// with plainText and key as parameters
	for (int i = 0; i < plainText.length(); i++) {
		// convert plaintext to uppercase
		plainText[i] = toupper(plainText[i]);
	}
	for (int i = 0; i < key.length(); i++) {
		// convert key to uppercase
		key[i] = toupper(key[i]);
	}
	string encryptedText = stringEncryption(plainText, key);

	// Printing cipher Text
	cout << "Cipher Text - " << encryptedText << endl;

	// Calling above method to stringDecryption
	// with encryptedText and key as parameters

	cout << "Message - " << stringDecryption(encryptedText, key);

	return 0;
}
