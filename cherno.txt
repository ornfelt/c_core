Including libraries in Visual studio guide:
https://lazyfoo.net/tutorials/SDL/01_hello_SDL/windows/msvc2019/index.php

Ref project: BirdGame
C:\Users\Svea User\source\repos\BirdGame\BirdGame
https://github.com/MariuszDot/Game_Flying_Dog

To include boost to c++ project:
Either use CMAKE LIKE THIS:
(see: C:\Users\Svea User\Documents\bd\c_core\boost)
cmake_minimum_required(VERSION 3.15)
project(TryOuts LANGUAGES CXX)
find_package(Boost QUIET REQUIRED COMPONENTS program_options)
if(NOT Boost_FOUND)
    message(FATAL_ERROR "Boost Not found")
endif()
add_executable(helloworld SimpleNetworking.cpp)
target_link_libraries(helloworld PUBLIC Boost::program_options)
---
Or in MS VS Code:
Right click project -> properties -> All configs -> VC++ Directories, then:
Add to "Include Directories" ";C:\local\boost_1_81_0;"
Add to "Library directories" ";C:\local\boost_1_81_0\stage\lib;"

See:
https://xavierlamorlette.fr/cpp/effective_modern_cpp/

----------------------------------------------
Stuff:

Forwarding reference is "an rvalue reference to a cv-unqualified template parameter", such
as in:
template <class T> void foo(T&& );

which means the above function can take both l-value and r-value reference.
The important feature of universal references / forwarding references is that they can
bind to objects and expressions of any value category.

C++98 didn’t have rvalue references, only “references” — what we now call “lvalue
references.” The rule was simply that a mutable reference would bind only to a mutable
lvalue, but a const reference could bind to anything:

void change(int&);
void observe(const int&);

int main() {
    int i = 41;
    change(i);    // OK, lvalue
    change(42);   // Error, rvalue
    observe(i);   // OK, lvalue
    observe(42);  // OK, rvalue
}

This applies even when that type int comes from type deduction:

template<class T>
void observe(const T&);

int main() {
    int i = 41;
    const int ci = 42;
    observe(i);   // OK, lvalue, T=int
    observe(ci);  // OK, lvalue, T=int
    observe(43);  // OK, rvalue, T=int
}

When C++11 invented rvalue references, none of this behavior changed at all. const T&
still binds happily to both lvalues and rvalues.

    const T& is the O.G. universal reference.

C++11 also invented the forwarding reference: that when there’s a deduced type T directly
modified by &&, T can sometimes be deduced as an lvalue reference type (even though this
never happens anywhere else in the language):

template<class T>
void forward(T&&);

int main() {
    int i = 41;
    const int ci = 42;
    forward(i);   // OK, lvalue, T=int&
    forward(ci);  // OK, lvalue, T=const int&
    forward(43);  // OK, rvalue, T=int
}

The advantage of T&& is that, by looking at whether T deduced as a reference type, you can
tell whether your caller considered the argument an lvalue or an rvalue. That’s not useful
information in its own right; it is useful only if you are planning to forward your
argument as its original value category — lvalues as lvalues, rvalues as rvalues. That’s
what std::forward<T>(t) is for.

If you see code using std::forward<T> without an originating T&&, it’s almost certainly
buggy. If you see code using (deduced) T&& without std::forward<T>, it’s either buggy or
it’s C++20 Ranges. (Ranges ill-advisedly uses value category to denote lifetime rather
than pilferability, so Ranges code tends to forward rvalueness much more conservatively
than ordinary C++ code does).

----------------------------------------------
Reference to pointer:

void myfunc(string*& val)
{
    // Do stuff to the string pointer
}

void myfunc2(string* const& val)
{
    // Do stuff to the string pointer
}

int main()
{
    // ...
    string s;
    string* ps = &s;

    myfunc(ps);   // OK because ps is not a temporary
    myfunc2(&s);  // OK because the parameter is a const&
    // ...

    return 0;
}

This is only useful if you intend to modify the pointer you pass to the function. If you
intend to modify the string itself you should use a reference to the string.
Typical usage would be: when you want the function to change the pointer itself, not
the object to which it points. For example, a function that allocates memory and assigns
the address of the memory block it allocated to its argument must take a reference to a
pointer, or a pointer to pointer:

void myfunc(string*& val)
{
    //val is valid even after function call
    val = new std::string("Test");
}

----------------------------------------------
C++17 introduced [[nodiscard]] attribute. When you declare a function [[nodiscard]], you
indicate that its return value should not be ignored. This can help prevent bugs related
to:

    Memory leak, in case the function returns a pointer to unmanaged memory.
    Performance, in case the discarded value is costly to construct.
    Security, in case the return value indicates an error condition that needs to be taken
    into account.

----------------------------------------------
A void pointer is a pointer that has no associated data type with it. A void pointer can
hold address of any type and can be typecasted to any type. In C++, we must explicitly
typecast return value of malloc to (int *).

int a = 10;
void* ptr = &a;
// cout << *ptr; // This will fail at compile-time
cout << *(int *)ptr << endl; // This will run

C allows a void* pointer to be assigned to any pointer type without a cast, whereas in
C++, it does not. We have to explicitly typecast the void* pointer in C++:
This is valid in C:
void* ptr;
int *i = ptr; // Implicit conversion from void* to int*
Also:
int *j = malloc(sizeof(int) * 5);  // Implicit conversion from void* to int

In C++ we need to do this:
void* ptr;
int *i = (int *) ptr;
int *j = (int *) malloc(sizeof(int) * 5);

----------------------------------------------
Difference Between malloc() and calloc():
malloc() allocates a memory block of given size (in bytes) and returns a pointer to the
beginning of the block. malloc() doesn’t initialize the allocated memory. If you try to
read from the allocated memory without first initializing it, then you will invoke
undefined behavior, which will usually mean the values you read will be garbage.

calloc() allocates the memory and also initializes every byte in the allocated memory to
0. If you try to read the value of the allocated memory without initializing it, you’ll
get 0 as it has already been initialized to 0 by calloc().

malloc() takes a single argument, which is the number of bytes to allocate. Is faster.
calloc() takes two arguments:
1) Number of blocks to be allocated.
2) Size of each block in bytes.

malloc() vs new:
New calls the constructors, malloc/calloc does not.
new is an operator, while malloc() is a function.
return type: new returns exact data type, while malloc() returns void *.
Failure Condition: On failure, malloc() returns NULL where as new throws
bad_alloc exception.

Memory: In case of new, memory is allocated from free store where as in
malloc() memory allocation is done from heap.
Size: Required size of memory is calculated by compiler for new, where as we
have to manually calculate size for malloc().
Buffer Size: malloc() allows to change the size of buffer using realloc() while
new doesn’t.

Dangling, Void, Null and Wild Pointers:

Danlig pointer examples:

int* ptr = (int *)malloc(sizeof(int));
// After below free call, ptr becomes a dangling pointer
free(ptr);
// No more dangling pointer
ptr = NULL;

int* fun()
{
    // x is local variable and goes out of
    // scope after an execution of fun() is over.
    int x = 5;
    return &x;
}

int main()
{
    int *p = fun();
    fflush(stdin);
    // p points to something which is not valid anymore
    std::cout << *p;
    return 0;
}

The above problem doesn’t appear (or p doesn’t become dangling) if x is a
static variable.
static int x = 5;

void main()
{
   int *ptr;
   {
       int ch;
       ptr = &ch;
   }
   // Here ptr is dangling pointer
}

Void pointer is a specific pointer type – void * – a pointer that points to some data
location in storage, which doesn’t have any specific type.
void pointers cannot be dereferenced. It can however be done using typecasting the void
pointer.
Pointer arithmetic is not possible on pointers of void due to lack of concrete value and thus size.

NULL vs Uninitialized pointer – An uninitialized pointer stores an undefined value. A null
pointer stores a defined value, but one that is defined by the environment to not be a
valid address for any member or object.
NULL vs Void Pointer – Null pointer is a value, while void pointer is a type.

Wild pointer:
A pointer that has not been initialized to anything (not even NULL) is known as wild pointer.

int *p;  /* wild pointer */
int x = 10;
p = &x;
// p is not a wild pointer now

----------------------------------------------
In Java, methods are virtual by default and can be made non-virtual by using the final
keyword. In C++ we need to:

// Superclass
class Base {
public:
    // In c++, non-virtual by default
    //void show()
    virtual void show()
    {
        cout << "Base::show() called";
    }
};

// Subclass
class Derived : public Base {

public:
    void show()
    {
        cout << "Derived::show() called";
    }
};

int main()
{
    Derived d;
    Base& b = d;
    b.show();
    getchar();
    return 0;
}

----------------------------------------------
Convert a std::vector<double> to a double array[]:
There's a fairly simple trick to do so, since the spec now guarantees vectors
store their elements contiguously:
std::vector<double> v;
double* a = &v[0];

However, the above trick doesn't copy, it creates a pointer that points to the
actual array the vector is using internally. If you want to copy:
double arr[100];
std::copy(v.begin(), v.end(), arr);

Using transform() function in C++ STL:
transform() function in C++ is used to copy a range of elements from one
container to another based upon a unary operation.
int n = v.size();
int arr[n];
std::transform(v.begin(),v.end(),arr,[](const int& x){return x;});

Using data() function in C++ STL:
data() function in C++ is used to copy a vector to the array by returning a
pointer to the first element in the array which is used internally by the
vector.
int * arr = v.data();

----------------------------------------------------------------------------------
Excplicit:

The compiler is allowed to make one implicit conversion to resolve the parameters to a
function. What this means is that the compiler can use constructors callable with a single
parameter to convert from one type to another in order to get the right type for a
parameter.

Here's an example class with a constructor that can be used for implicit conversions:

class Foo
{
private:
    int m_foo;

public:
    // single parameter constructor, can be used as an implicit conversion
    Foo (int foo) : m_foo (foo) {}

    int GetFoo () { return m_foo; }
};

Here's a simple function that takes a Foo object:

void DoBar (Foo foo)
{
    int i = foo.GetFoo();
}
and here's where the DoBar function is called:

int main ()
{
    DoBar(42);
}

The argument is not a Foo object, but an int. However, there exists a constructor for Foo
that takes an int so this constructor can be used to convert the parameter to the correct
type.

The compiler is allowed to do this once for each parameter.

Prefixing the explicit keyword to the constructor prevents the compiler from using that
constructor for implicit conversions. Adding it to the above class will create a compiler
error at the function call DoBar (42). It is now necessary to call for conversion
explicitly with DoBar (Foo (42))

The reason you might want to do this is to avoid accidental construction that can hide
bugs.

Contrived example:
You have a MyString class with a constructor that constructs a string of the given size.
You have a function print(const MyString&) (as well as an overload print (char *string)),
and you call print(3) (when you actually intended to call print("3")). You expect it to
print "3", but it prints an empty string of length 3 instead.

----------------------------------------------------------------------------------
lvalue and rvalue:

An lvalue reference is formed by placing an & after some type.

A a;
A& a_ref1 = a;  // an lvalue reference
An rvalue reference is formed by placing an && after some type.

A a;
A&& a_ref2 = a;  // an rvalue reference

An rvalue reference behaves just like an lvalue reference except that it can
bind to a temporary (an rvalue), whereas you can not bind a (non const) lvalue
reference to an rvalue.

A&  a_ref3 = A();  // Error!
A&& a_ref4 = A();  // Ok

The biggest difference between a C++03 reference (now called an lvalue reference in C++11)
is that it can bind to an rvalue like a temporary without having to be const. Thus, this
syntax is now legal:
T&& r = T();

rvalue references primarily provide for Move semantics.

----------------------------------------------

void foo(X& x);  // lvalue reference overload
void foo(X&& x); // rvalue reference overload

X x;
X foobar();

foo(x);        // argument is lvalue: calls foo(X&)
foo(foobar()); // argument is rvalue: calls foo(X&&)

----------------------------------------------
Rewriting loop:

int calculate(int bottom, int top)
{
    if (top > bottom)
    {
        int sum = 0;
        for(int number = bottom; number <= top; number++){
            if (number % 2 == 0)
                sum += number;
        }

        return sum;
    }
    else
        return 0;
}

Using C++ 20 views::iota:

int calculate(int bottom, int top)
{
    if (top > bottom) {
        int sum = 0;
        // Use views::iota adapter to loop through range instead
        // Top + 1 since it's not inclusive (doesn't include the last one)
        for(int number : std::views::iota(bottom, top + 1)) {
            if (number % 2 == 0)
                sum += number;
        }
        return sum;
    }
    else
        return 0;
}

Using filter to filter out odd values, replaces the if check:

int calculate(int bottom, int top)
{
    if (top > bottom) {
        int sum = 0;
        // Lambda 
        auto even = [](auto e) { return e % 2 == 0; };

        for(int number : std::views::iota(bottom, top + 1) | std::views::filter(even)) {
            sum += number;
        }
        return sum;
    }
    else
        return 0;
}

Replace int sum and for loop with accumulate:

int calculate(int bottom, int top)
{
    if (top > bottom) {
        int sum = 0;
        // Lambda 
        auto even = [](auto e) { return e % 2 == 0; };

        auto evens = std::views::iota(bottom, top + 1) | std::views::filter(even);
        return std::accumulate(evens.begin(), evens.end(), 0);
    }
    else
        return 0;
}

----------------------------------------------------------------------------------
Move semantics:

Basic string class to demonstrate why we might need moving:

#include <iostream>
class String {
    public:
        String() = default;
        String(const char* string)
        {
            printf("Created!\n");
            // null termination char needed as well, but we skip for this example
            m_Size = strlen(string);
            m_Data = new char[m_Size];
            // Move source string to m_Data buffer
            memcpy(m_Data, string, m_Size);
        }

        // We also add a way to print the string
        void Print()
        {
            for(uint32_t i = 0; i < m_Size; i++)
                printf("%c", m_Data[i]);

            printf("\n");
        }

    private:
        char* m_Data;
        uint32_t m_Size;
};

int main() {
    std::cin.get();
}

// Entity class that will consume our string
class Entity {
    public:
        Entity(const String& name) : m_Name(name)
    {
    }

        void PrintName()
        {
            m_Name.Print();
        }

    private:
        String m_Name;
};

int main()
{
    Entity entity("Cherno"); // Using implicit constructor
    // You can do this as well for clarity (what actually happens above)
    Entity entity(String("Cherno"));

    std::cin.get();
}

// For the above to work we need a copy constructor in String class
// Put the functions below the String constructor
String(const String& other)
{
    printf("Copied!\n");
    m_Size = other.m_Size; // Copy from other
    m_Data = new char[m_Size];
    memcpy(m_Data, other.m_Data, m_Size); // Copy from other
}

~String()
{
    printf("Destroyed!\n");
    delete m_Data;
}


// The bad thing is that to copy a string we need to allocate memory on the heap due to:
String(const String& other)
{
    ...
    m_Data = new char[m_Size];
    ...
}

// We just want to move it, not actually copy it. We can do that by creating a move
// constructor

// Takes rvalue reference, noexcept since it won't throw exceptions
String(String&& other) noexcept
{
    printf("Moved!\n");
    m_Size = other.m_Size; // Copy from other
    m_Data = other.m_Data; // Make sure that our pointer points to the same data as other
    // If we leave it here, the problem is that the destructor of the other string will be
    // called and it will remove the m_Data that the new string now points to...
    // We also need to do this (take control over other.m_Data):
    // The below will create a hollow object, so when it gets destroyed it will delete
    // nullptr which is nothing (doesn't do anything)
    other.m_Data = nullptr;
    other.m_Size = 0;
}

// To call the move constructor we need to add an Entity constructor that takes a
// temporary:
// The (String&& is necessary to cast it to a temporary, otherwise the move constructor
// won't be called. Copy will be called instead...

Entity(String&& name) : m_Name((String&&) name) // This will call the move constructor
{
}
// In practice you wouldn't cast it to an rvalue reference like this, you would use
// std::move instead which essentially does the same thing:
// Use below:
Entity(String&& name) : m_Name(std::move(name)) // This will call the move constructor
{
}

// You probably also need to use this instead of the String("cherno") in main
Entity entity("Cherno"); // Using implicit constructor

// Other video (continuation)
// std::move and the Move Assignment Operator in C++
// In main, if we wish to copy a string like this:
String string = "Hello";
String dest = string; // This will copy the string
// How to move it instead? Make it into a temporary object (rvalue reference)

If we wish to use the move constructor with the = operator:
// This is a move assignment operator
String& operator=(String&& other) noexcept
{
    // In the move constructor above we're actually moving another object into the current
    // object. In this case we need to overwrite the current object because the current
    // object might have some memory allocated. so if we do m_Data = other.m_Data we create a
    // memory leak because then we can't delete that old data...
    // So, we need to delete our current data

    // We also need to check that other isn't the same as this.
    // Otherwise something like: dest = std::move(dest) would delete the current data
    if (this != &other)
    {
        delete[] m_Data;

        printf("Moved (=operator)!\n");
        m_Size = other.m_Size; // Copy from other
        m_Data = other.m_Data; // Make sure that our pointer points to the same data as other
        other.m_Data = nullptr;
        other.m_Size = 0;
    }

    return *this; // Return reference to the current object
}

// To test the move assignment operator in main we can do:
String apple = "Apple";
String dest;
// dest = apple; // This won't work since we don't have a copy assignment operator
dest = std::move(apple);
// Now apple points to nothing since dest stole apple's data
An operator is basically a function, so we can replace dest = std::move(apple) with:
dest.operator=(std::move(apple));

// This won't work since we're not actually calling the assignment operator. We're just
constructing a new string that happens to use a temporary value so the move constructor is
called:
String dest = std::move(apple);

// So, std::move converts an object to be a temporary. If you need an existing variable to
become a temporary in the sense that you're basically marking it as hey "you can steal
resources from this particular variable".
If you're creating a new variable and it's like in a function parameter or in the move
constructor then its already a temporary so it's fine. But if you have an existing
variable like apple, then std::move is appropriate.

----------------------------------------------------------------------------------
Auto vs decltype::

decltype gives the declared type of the expression that is passed to it. auto does the
same thing as template type deduction. So, for example, if you have a function that
returns a reference, auto will still be a value (you need auto& to get a reference), but
decltype will be exactly the type of the return value.

#include <iostream>
int global{};
int& foo()
{
   return global;
}

int main()
{
    decltype(foo()) a = foo(); // a is an `int&`
    auto b = foo(); //b is an `int`
    b = 2;

    std::cout << "a: " << a << '\n'; //prints "a: 0"
    std::cout << "b: " << b << '\n'; //prints "b: 2"

    std::cout << "---\n";
    decltype(foo()) c = foo(); //c is an `int&`
    c = 10;

    std::cout << "a: " << a << '\n'; //prints "a: 10"
    std::cout << "b: " << b << '\n'; //prints "b: 2"
    std::cout << "c: " << c << '\n'; //prints "c: 10"
 }

auto (in the context where it infers a type) is limited to defining the type of a variable
for which there is an initializer. decltype is a broader construct that, at the cost of
extra information, will infer the type of an expression.

In the cases where auto can be used, it is more concise than decltype, as you don't need
to provide the expression from which the type will be inferred.

auto x = foo();                           // more concise than `decltype(foo()) x`
std::vector<decltype(foo())> v { foo() };  // cannot use `auto`
The keyword auto is also used in a completely unrelated context, when using trailing
return types for functions:

auto foo() -> int;
There auto is only a leader so that the compiler knows that this is a declaration with a
trailing return type. While the example above can be trivially converted to old style, in
generic programming it is useful:

template <typename T, typename U>
auto sum(T t, U u) -> decltype(t+u)
Note that in this case, auto cannot be used to define the return type.

----------------------------------------------
Functor::
Consider a function that takes only one argument. However, while calling this function we
have a lot more information that we would like to pass to this function, but we cannot as
it accepts only one parameter. What can be done?
One obvious answer might be global variables. However, good coding practices do not
advocate the use of global variables and say they must be used only when there is no other
alternative.

Functors are objects that can be treated as though they are a function or function
pointer. Functors are most commonly used along with STLs (like transform).

#include <bits/stdc++.h>
using namespace std;

// A Functor
class increment
{
    private:
        int num;
    public:
        increment(int n) : num(n) { }

        // This operator overloading enables calling
        // operator function () on objects of increment
        int operator () (int arr_num) const {
            return num + arr_num;
        }
};

// Driver code
int main()
{
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr)/sizeof(arr[0]);
    int to_add = 5;

    transform(arr, arr+n, arr, increment(to_add));

    for (int i=0; i<n; i++)
        cout << arr[i] << " ";
}

See what’s happening? As transform requires a unary function (function taking only one
argument) for an array, we cannot pass a number to increment(). And this would, in effect,
make us write several different functions to add each number. What a mess. This is where
functors come into use.

A functor (or function object) is a C++ class that acts like a function.
Functors are called using the function call syntax. To create a functor, we
create an object that overloads the operator().

----------------
Example: Sorting Mail
Now we can think about how we'd want to write a mail sorting functor. We'd need operator()
to take two messages, and we can have its constructor store the field we wish to sort by.

class Message
{
    public:
        std::string getHeader(const std::string& header_name) const;
        // other methods...
};

class MessageSorter
{
    public:
        // take the field to sort by in the constructor
        MessageSorter (const std::string& field) : _field(field) {}

        bool operator() (const Message& lhs, const Message& rhs)
        {
            // get the field to sort by and make the comparison
            return lhs.getHeader(_field) < rhs.getHeader(_field);
        }
    private:
        std::string _field;
};

Now if we had a vector of Messages, we could use the STL sort function to sort them:
std::vector<Message> messages;
// read in messages
MessageSorter comparator;
sort(messages.begin(), messages.end(), comparator);

----------------
A functor is pretty much just a class which defines the operator(). That lets you create
objects which "look like" a function:

// this is a functor
struct add_x {
    add_x(int val) : x(val) {}  // Constructor
    int operator()(int y) const { return x + y; }

    private:
    int x;
};

// Now you can use it like this:
add_x add42(42); // create an instance of the functor class
int i = add42(8); // and "call" it
assert(i == 50); // and it added 42 to its argument

std::vector<int> in; // assume this contains a bunch of values
std::vector<int> out(in.size());

// Pass a functor to std::transform, which calls the functor on every element 
// in the input sequence, and stores the result to the output sequence
std::transform(in.begin(), in.end(), out.begin(), add_x(1));
assert(out[i] == in[i] + 1); // for all i

There are a couple of nice things about functors. One is that unlike regular functions,
they can contain state. The above example creates a function which adds 42 to whatever you
give it. But that value 42 is not hardcoded, it was specified as a constructor argument
when we created our functor instance. I could create another adder, which added 27, just
by calling the constructor with a different value. This makes them nicely customizable.

As the last lines show, you often pass functors as arguments to other functions such as
std::transform or the other standard library algorithms. You could do the same with a
regular function pointer except, as I said above, functors can be "customized" because
they contain state, making them more flexible (If I wanted to use a function pointer, I'd
have to write a function which added exactly 1 to its argument. The functor is general,
and adds whatever you initialized it with), and they are also potentially more efficient.
In the above example, the compiler knows exactly which function std::transform should
call. It should call add_x::operator(). That means it can inline that function call. And
that makes it just as efficient as if I had manually called the function on each value of
the vector.

If I had passed a function pointer instead, the compiler couldn't immediately see which
function it points to, so unless it performs some fairly complex global optimizations,
it'd have to dereference the pointer at runtime, and then make the call.

----------------------------------------------
How to make your STRINGS FASTER in C++!
Strings are bad / slow since they allocate memory. std::string allocates memory.

static uint32_t s_AllocCount = 0;

void* operator new(size_t size)
{
    s_AllocCount++;
    std::cout << "Allocating " << size << " bytes\n";
    return malloc(size);
}

Example:
// const string reference (no copy when sent to the function)
void PrintName(const std::string& name)
{
    std::cout << name << std::endl;
}

int main()
{
    std::string name = "Yan Chernikov";
    // Let's see how many times we copy when calling PrintName
    // To see this we can overload the new operator (see above)
    PrintName(name);

    // Print final allocations
    std::cout << s_AllocCount << " allocations" << std::endl;
    std::cin.get();
}

Running the above code result in "Allocating 8 bytes" 1 allocations.
Using a break point we can see that std::string name = "Yan.." is causing the
heap allocation.

What if we skip that and do this instead?
PrintName("Yan Chernikov"); 

The allocation will happen in PrintName since the std::string needs to be constructed
because PrintName expects an std::string.

If we now play around a bit in the main method and do this instead:
int main()
{
    std::string name = "Yan Chernikov";
    std::string firstName = name.substring(0, 3); // First 3 chars
    std::string lastName = name.substring(4, 9); // First 3 chars
    PrintName(firstName);

    // Print final allocations
    std::cout << s_AllocCount << " allocations" << std::endl;
    std::cin.get();
}

With the above we get Allocating 8 bytes 3 times and "3 allocations".

With std::string_view we can be more efficient and skip all allocations above...

string_view introduced in C++ 17. It's a pointer to existing memory. const char* pointer
to existing string, plus a size. So then we can get the firstname instead by having a
pointer to the first character and the size 3 to get a "substring". Or we can have a
pointer to the beginning of the string + 4 bytes which is the beginning of the lastname
and a size of 9 to get the last name. Sort of like a window sliding technique.

Now we can do:

#define STRING_VIEW 1

#if STRING_VIEW
void PrintName(const std::string_view name) // No need for reference
{
    std::cout << name << std::endl;
}
#else
void PrintName(const std::string& name)
{
    std::cout << name << std::endl;
}
#endif

int main()
{
    std::string name = "Yan Chernikov";
#if STRING_VIEW
    // c_str returns a const char pointer
    std::string_view firstName(name.c_str(), 3);
    std::string_view lastName(name.c_str() + 4, 9);
#else
    std::string firstName = name.substring(0, 3); // First 3 chars
    std::string lastName = name.substring(4, 9); // First 3 chars
#endif

    PrintName(firstName);
    // We also need to add std::string_view to the PrintName arguments, see above

    // Print final allocations
    std::cout << s_AllocCount << " allocations" << std::endl;
    std::cin.get();
}

The above only gives 1 allocation. To get 0 allocations we can simply use:
const char* name = "Yan Chernikov"; instead

----------------------------------------------
String Literals in C++:

String literals are always stored in read-only memory.

// The below will print 3 because of the null termination char
const char name[8] = "Che\0rno";
std::cout << strlen(name) << std::endl;
std::cin.get();

// We can also assign the char array to const char*
// The const prevents from changing by doing name[2] = 'a' for example
const char name* = "Cherno";
std::cout << name << std::endl;
std::cin.get();

If const is removed, it might look like it should work but its undefined behavior...
Some compilers will compile but most won't...
MSVC compiles the above 
It doesn't work because you've created a pointer to the mem location of a string literal
(stored in read only). If you go into the compiler settings -> all configs -> C++ ->
Output files -> Assembler Output: set assembly with source code.
If the project is built in release now we can see in the assembly code that there's:
CONST   SEGMENT
xxxxxx Cherno
CONST   ENDS

If we look in the exe file in HxD (hex editor) we can see Cherno inside the binary.
If you try to edit the pointer like this:
const char name* = "Cherno";
name[2] = 'a';
std::cout << name << std::endl;
std::cin.get();

In release mode, the code will run but the character won't be changed (due to compiler
optimizations in release mode).
In debug mode it will fail saying "Exception thrown: write access violation".
You can modify it if you change it to: const char name[] = "Cherno";

const char* name = u8"Cherno"; // You can skip the u8. 1 byte per char. Utf8
const wchar_t* name2 = L"Cherno"; // 2 bytes per char. Differs from char16_t:
// 16 bits per char or 2 bytes per char. Adhere's with utf16
const char16_t* name3 = u"Cherno";
// 32 bits or 4 bytes per char. Adhere's with utf32
const char32_t* name4 = U"Cherno";

// The R (raw) ignores escape characters, so we can do:
const char* example = R"(line1
line2
line3)";

In C++ you usually declare a char pointer as: const char* name = "test";
Because you'd preferably don't want to be going around changing the value of it since
strings are immutable in the sense that you can't extend a string and make it bigger
becasue it's a fixed allocated block of memory. If you need a bigger string, you need to
peform a brand new allocation and delete the old string.
Even if it's heap-allocated, you don't need to delete char pointers...
Also, std::strings in C++ are const char arrays... (also why const char* tends to be used
as mentioned above).
When passing strings (and most other objects as well) you should pass them as const
reference: void PrintString(const std::string& s)
Reference so that it won't get copied into a new object, and const since we're promising
to not change it.

----------------------------------------------
C++ const:

const int MAX_AGE = 90;
int* a = new int; // Created on the heap
*a = 2;
a = (int*)&MAX_AGE; // This can be done in some cases if you wish to modify a const
// variable (you shouldn't). It might lead to a crash if the compiler treats the const as
// readonly... Just using a = &MAX_AGE won't work since it's constant... We cast to int
// pointer instead

// Using const like this means that you can't modify the contents of the pointer.
// You can't do *a = 2 for example... You can still do a = (int*)&MAX_AGE; however.
// Note that const int* is the same as int const*
// The key here is that const is before the pointer sign above, whereas if 
// to make the pointer constant so that you can't reassign the poitner, you need to
// do it like this: int* const a;
const int* a = new int; 

// This is the opposite, you can change the content but not reassign the pointer.
int* const a = new int;

Observer that these are the same:
const int* a = new int;
int const* a = new int;

// Print dereferenced pointer and wait for input...
std::cout << *a << std::endl;
std::cin.get();

Using const after a method name (can only be done in a class method) means that the method
isn't modifying the class.
For example:
class Entity
{
    private:
        int m_X, m_Y;
    public:
        int GetX() const { return m_X; }
        void SetX(int x) { m_X = x; }
}

Note: if you really need to modify a variable inside a const method (maybe for debugging
purposes) then you can do it thanks to the mutable keyword:
class Entity
{
    private:
        int* m_X, m_Y; // Only m_X is pointer in this case, not m_Y. Put * before m_Y if
                       //you want it to be pointer as well...
        mutable int var;
    public:
        int GetX() const
        {
            var = 2; // Allowed thanks to mutable
            return m_X;
        }
        void SetX(int x) { m_X = x; }
}

If you wish to have x as pointer and have it constant all around then you can do this
mysterious code:
class Entity
{
    private:
        int* m_X, m_Y; // Only m_X is pointer in this case, not m_Y. Put * before m_Y if
                       //you want it to be pointer as well...
    public:
        // This means that we're returning a pointer that can't be modified, the contents
        // of the pointer can't be modified and the method promises not to modify the
        // Entity class.
        const int const GetX() const { return m_X; } // C++...
        void SetX(int x) { m_X = x; }
}

void printEntity(const Entity& e)
{
    // const reference means we can't modify the Entity like e = Entity();
    std::cout << e.GetX() << std::endl;
}

Notes:
Pass by const reference to avoid copying:
void PrintEntity (const Entity& e)
//e = Entity(); // Not possible becasue of const...
std::cout << e.GetX() << std::endl;

This line will not create two pointers, only m_X will be a pointer:
int* m_X, m_Y;
int* m_X, *m_Y; // This will create two pointers

----------------------------------------------
Smart pointers:
Unique pointers are unique (can't be copied since when it goes out of scope, it will get
destroyed and that would cause problems for another pointer pointing to the same memory)
It's a scoped pointer that gets destroyed after going out of scope...

For example:
class Entity {
    public:
        // Constructor and destructor so that we can see creation / deletion
        Entity() { std::cout << "Created Entity!" << std::endl; }
        ~Entity() { std::cout << "Destroyed Entity!" << std::endl; }
        void Print() {}
};

// then create unique pointer
int main () {
    // Create scope manually with {}
    {
        //std::unique_ptr<Entity> entity(new Entity());
        // The preffered way is to create unique pointer like this, due to Exception safety (to
        // avoid dangling pointer / memory leak if the constructor throws exception...)
        std::unique_ptr<Entity> entity = std::make_unique<Entity>();
        entity->Print();
    }
    std:.cin.get();
}

With shared pointer you can copy the pointer. It uses reference counting.
The pointer gets deleted when reference count is 0...
int main () {
    // Create scope manually with {}
    {
        // Use this way to create shared pointer as well - more important
        // due to efficiency, otherwise if you create it with new, you will effectively
        // construct a new entity and pass it to make shared which also needs to construct
        // its control block, if you use make_shared it can do both of these together
        std::shared_ptr<Entity> sharedEntity = std::make_shared<Entity>();
        std::shared_ptr<Entity> e0 = sharedEntity; // Now this works

        // You can use weak_ptr to NOT take ownership of the Entity since it won't
        // increase the ref count!
        std::weak_ptr<Entity> weakEntity = sharedEntity; // Won't be kept alive when
                                                         // shared pointer goes out of scope...
        sharedEntity->Print();
        // Try to prioritize using unique_ptr first, otherwise shared_ptr if needed.
    }
std:.cin.get();
}

----------------------------------------------
Templates in C++:

template<typename T>
void Print(T value)
{
    std::cout << value << std::endl;
    // If you misspell value it will still compile UNLESS you call the function in main
    // for example. If you don't call it the code will not be generated for templates...
    //std::cout << val << std::endl;
}

In template<typename T> you can also write template<class T> (same thing)...

You can call it with a specified type: Print<int>(5);
You can just use Print(5) or Print("Cherno") since the compiler can work it out for these
types...

Use-case scenario when creating a stack-allocated array without knowing size at compile
time, and without using alloca. Sort of C-styled array:

template<int N>
class Array
{
    private:
        // We can't use a variable size since its a stack allocated array and it needs to be
        // known at compile-time
        // int m_Array[size];
        // int m_Array[10]; // This won't be dynamic
        int m_Array[N]; // This works!

    public:
        int GetSize() const { return N; }
};

int main ()
{
    // With this example, the template usage will essentially result in a version of class
    Array being created where int m_Array[N] is int m_Array[5];
    Array<5> array;
    std::cin.get();
}

You can also specify what type the array should be with this:
typename<typename T, int N>
class Array
{
    private:
        T m_Array[N]; // This works with any types!
    public:
        int GetSize() const { return N; }
};

// Usage:
Array<std::string, 50> array;
std::cout << array.GetSize() << std::endl;

----------------------------------------------
Struct (structure) is exactly like class except the default accessibility is public for
struct (while it's private for class.

Cherno strategy:
Use struct when using plain variables. Like a mathematical vector class:
struct Vec2
{
    float x, y; // Only two variables 
                // You can also have a few methods changing the variables:
    void Add(const Vec2& other)
    {
        x+= other.x;
        y+= other.y;
    }
}

A class "should" contain more functionality. Inheritance is possible with structs but they
"should" be used with classes if we follow the strategy of keeping structs simple and
inheritance adds a layer of complexity so therefore class inheritance is more fitting...

----------------------------------------------
Program using template and decltype and auto:

// decltype Keyword: It inspects the declared type of an entity or the type of an
// expression. ‘auto’ lets you declare a variable with a particular type whereas decltype
// lets you extract the type from the variable so decltype is sort of an operator that
// evaluates the type of passed expression. 

// C++ program to demonstrate use of decltype in functions
#include <bits/stdc++.h>
using namespace std;

// A generic function which finds minimum of two values
// return type is type of variable which is minimum
template <class A, class B>
auto findMin(A a, B b) -> decltype(a < b ? a : b)
{
    return (a < b) ? a : b;
}

// driver function to test various inference
int main()
{
    // This call returns 3.44 of double type
    cout << findMin(4, 3.44) << endl;

    // This call returns 3 of double type
    cout << findMin(5.4, 3) << endl;

    return 0;
}

auto (in the context where it infers a type) is limited to defining the type of a variable
for which there is an initializer. decltype is a broader construct that, at the cost of
extra information, will infer the type of an expression.

#include <iostream>
int global{};
int& foo()
{
   return global;
}

int main()
{
    decltype(foo()) a = foo(); //a is an `int&`, gets the returned type...
    auto b = foo(); //b is an `int`
    b = 2;

    std::cout << "a: " << a << '\n'; //prints "a: 0"
    std::cout << "b: " << b << '\n'; //prints "b: 2"

    std::cout << "---\n";
    decltype(foo()) c = foo(); //c is an `int&`
    c = 10;

    std::cout << "a: " << a << '\n'; //prints "a: 10"
    std::cout << "b: " << b << '\n'; //prints "b: 2"
    std::cout << "c: " << c << '\n'; //prints "c: 10"
 }

----------------------------------------------
Whereas in type conversion, a data type is converted into another data type by a compiler.
Example:
int x=30;
float y;
y=x;  // y==30.000000.

Casting:
float x;
byte y;
...
...
y=(byte)x;  //Line 5

Type casting can be applied to compatible data types as well as incompatible data types
whereas type conversion can only be applied to compatible datatypes.

----------------------------------------------------------------------------------
// ARRAY - Making DATA STRUCTURES in C++

#include <iostream>
#include <array> // Needed for std::array (C++11+)

int main()
{
    // Creating array on the stack
    int size = 5;
    int array[5]; // int array[size] doesn't work unless size is const since compiler needs to know size at compile time if allocated on the stack

    // Creating array on the heap
    int* heapArray = new int[size];
    delete[] heapArray; // Needs to be deleted

    // Using standard array (std)

    std::array<int, 10> collection;
    collection.size(); // Get size of array
    // for(int i = 0; i < collection.size(); i++) // Looping the array
    // for (int i : collection) // Looping with iterator
}

// Creating a custom array class:

class Array {
    public:
        Array(int size){
            // Alloca takes size in bytes and allocates memory on stack
            // A few caveats for alloca: compiler won't know how much memory space is
            // needed at compile time, so a few optimizations are skipped...

            // m_data = (int*)alloca(size * sizeof(int));

            // We can still use int_mdata[10] and not use alloca, if we use template!
            // See code below!
        }
    private:
        // How can we dynamically allocate memory on the stack?
        // Use pointer and alloca
        //int m_data[10];
        int* m_data;
};

int main()
{
    // Now we can do this:
    int size = 5;
    Array data(size); // Or: data(5);
}


template<typename T, size_t S> // You can use int instead of size_t, but size_t should be used
class Array {
public:
	//int Size() const { return S; }
	// constexpr int Size() const { return S; }
	// This should also be size_t 
	constexpr size_t Size() const { return S; }

	// Create index operator
	// Needs to be reference since otherwise we can't change by doing data[i] = 2;
	//T& operator[](int index) { return m_data[index]; }

	// If we have a const array ref like this below (in main): const auto& arrayRef = data;
	// Then, we need the following to be able to read from the array
	//const T& operator[](int index) const { return m_data[index]; }
	// Also, we should use size_t instead of int since int can be negative etc.
	T& operator[](size_t index) { return m_data[index]; }
	const T& operator[](size_t index) const { return m_data[index]; }

	// The stl array also has a check to see that the used index is in range of the
	// array. We can add something like this:
	// We typically skip this in production since it should caught when debugging...
	// T& operator[](size_t index) { 
	// 	if (!(index < S))
	// 		_debugbreak(); // This is MSVC specific debug break
	// 	return m_data[index]; 
	// }

	// Another thing we need is a way to access the data
	T* Data() { return m_data; }
	// We can also add a const version:
	const T* Data() const { return m_data; }
	// This enables you to do set the memory to be 0 like this (should be in main):
	// memset(data.Data(), 0, data.Size() * sizeof(int));
	// The above sets all ints to 0 by setting all the memory in the array to 0
	// You could also do this (without the functions to retrieve Data above)
	// This will take the address of the first index of the array which works since 
	// the array is guaranteed to be contiguous in memory...
	// memset(&data[0], 0, data.Size() * sizeof(int));

private:
	//int m_data[S];
	T m_data[S];
};

int main()
{
	// Now we can do this:
	int size = 5;
	Array<int, 5> data;

	// Something we can do to assert array size at compile time:
	// This requires that we change int Size() above to constexpr int Size()
	// This will specify that the Size() function is can be evaluated at compile time
	static_assert(data.Size() < 10, "Size is too large!");
	
	// We can also use the data size when creating new arrays
	Array(std::string, data.Size()> newArray;
	
	// Looping elements of data
	//for(int i = 0; i < data.Size(); i++){
	for(size_t i = 0; i < data.Size(); i++){
		std::cout << data[i] << std::endl;
	}

	// The above will print uninitialized memory...
	// Now if try to set some data:
	memset(data.Data(), 0, data.Size() * sizeof(int));
	data[1] = 5;
	data[4] = 8;

	for(size_t i = 0; i < data.Size(); i++){
		std::cout << data[i] << std::endl;
	}

	// We can't do this however
	// We need to write an iterator for this...
	//for(auto& elem : data){
	//}

	std::cin.get();
}

----------------------------------------------------------------------------------
// VECTOR/DYNAMIC ARRAY - Making DATA STRUCTURES in C++

#include <iostream>
#include <Array>
#include <Vector.h> // We create the Vector.h file

int main() {
	// Some example usage from the array data class
	Array <std::string, 2> data;
	data[0] = "Cherno";
	data[1] = "C++";

	// Example usage of the vector we're going to define (useful to create before creating
	// the actual data class / api.
	Vector<std::string> vector;

	vector.push_back("Cherno");
	vector.push_back("C++");
	vector.push_back("Vector");

	// try to print vector
	PrintVector(vector);

	// We should also add emplace_back which is very useful

	std::cin.get();
}

// Function to print the vector class defined below
// Use template as we don't know what type it consists of
template<typename T>
void PrintVector(const Vector<T>& vector)
{
	for(size_t i = 0; i < vector.Size(); i++){
		std::coud << vector[i] << std::endl;
	}
	std::coud << "----------------------------\n";
}

In Vector.h:

#pragma once

// Templated class
Template<typename T>
class Vector {
public:
	Vector() {
		// Allocate elements - start with 2
		ReAlloc(2);
	}

	void push_back(const T& value) {
		// Check if we need to reallocate memory
		if (m_size >= m_capacity) {
			ReAlloc(m_capacity + m_capacity / 2); // Grow with 50% each time we reallocate
			// The amount we reallocate could be changed... Reallocating 1 more would be
			// inefficient since it will reallocate each time an element is added...
			// (Might be good in some scenarios)
		}

		// Push back element
		m_data[m_size] = value;
		m_size++;
	}

	// Get size
	size_t Size() const { return m_size; }

	// Add index operator so that we can acces the data
	const T& operator[](size_t index) const
	{
		// Check that a valid index is called, usually only used in debug
		if (index >= m_size)
			// assert...

		return m_data[index];
	}

	T& operator[](size_t index)
	{
		// Check that a valid index is called, usually only used in debug
		if (index >= m_size)
			// assert...
		return m_data[index];
	}


private:
	void ReAlloc(size_t newCapacity) {
		// 1. Allocate new block of memory. In complicated vector implementations we can
		// create custom allocator functions (instead of new) to design an allocator that
		// won't hit the heap for example, every time it shuld allocate new memory...
		// In this implementation we simply use new...
		// 2. Copy (move) existing elements to the new vector.
		// 3. Delete old

		// Could use unique pointer or shared pointer for example, but this should be
		// avoided when you're this low level into things, like allocations and custom data
		// structures
		T* newBlock = new T[newCapacity]; // 1.

		// Check if we're downsizing
		if (newCapacity < m_size)
			m_size = newCapacity;

		// 2.
		for(size_t = 0; i < m_size; i++){
			newBlock[i] = m_data[i];

			// We can't use memcpy because we need to be hitting the copy constructor of
			// all of these elements. If we had a bunch of integers / floats or any
			// primitive type, then we can use memcpy, but for more complex types like
			classes that might have allocations of their own which the copy constructor will
			then perform a deep copy on, it's important for us thtat we're actually
			calling that copy constructor to copy it correctly.
		}

		// 3.
		delete[] m_data;

		m_data = newBlock;
		m_capacity = newCapacity;
	}

private:
	// Pointer to whatever type the vector is
	T* m_data = nullptr;
	// Number of elements in the vector
	size_t m_size = 0;
	// How much we can store without reallocating
	size_t m_capacity = 0;

};

--------------------------

// To demonstrate the usage of emplace_back:
// Used to detect copies, removals and moving...

struct Vector3 {
	float x = 0.0f, y = 0.0f, z = 0.0f;

	Vector3() {}
	Vector3(float scalar) 
		: x(scalar), y(scalar), z(scalar) {}
	Vector3(float x, float y, float z) 
		: x(x), y(y), z(z) {}

	Vector3(const Vector3& other)
		: x(other.xx), y(other.xy), z(other.z)
	{
		std::cout << "Copy\n";
	}

	Vector3(const Vector3&& other) 
		: x(other.x), y(other.y), z(other.z)
	{
		std::cout << "Move\n";
	}

	~Vector3()
	{
		std::cout << "Destroy\n";
	}

	// Move and assign operators
	Vector3& operator=(const Vector3& other)
	{
		std::cout << "Copy\n";
		x = other.x;
		y = other.y;
		z = other.z;
		return *this;
	}

	Vector3& operator=(Vector3&& other)
	{
		std::cout << "Move\n";
		x = other.x;
		y = other.y;
		z = other.z;
		return *this;
	}
}

// Function to print the vector class with Vector3
template<>
void PrintVector(const Vector<Vector3>& vector)
{
	for(size_t i = 0; i < vector.Size(); i++){
		std::coud << vector[i].x << vector[i].y << vector[i].z << std::endl;
	}
	std::coud << "----------------------------\n";
}

int main()
{
	Vector<Vector> vector;

	vector.push_back(Vector3(1.0f)); // Scalar
	vector.push_back(Vector3(2,3,4); // x,y,z
	vector.push_back(Vector3());

	PrintVector(vector);
	// This should print something like:
	/*
	Copy
	Destroy
	Copy
	Copy
	Destroy
	Destroy
	Copy
	Destroy
	1, 1, 1
	2, 3, 4
	0, 0, 0
	*/
}

--------------------------
// Now let's try to reduce the amount of copying...

// These are actually temporaries... The only reason Vector3(1.0f) is there is that we
// want to push it into the vector...
// vector.push_back(Vector3(1.0f)); // Scalar
// vector.push_back(Vector3(2,3,4); // x,y,z
// vector.push_back(Vector3());


// We could write another push_back function above that actually takes a temporary:

void push_back(const T&& value) {

	// Check if we need to reallocate memory
	if (m_size >= m_capacity) {
		ReAlloc(m_capacity + m_capacity / 2); // Grow with 50% each time we reallocate
	}

	// Push back element
	//m_data[m_size] = value; // Instead of assigning, we move it 
	// Move will casts the value to be an rvalue reference. The T&& in the argument
	// means value is an lvalue 
	m_data[m_size] = std::move(value); // Instead of assigning, we move it 

	m_size++;
}

// After we implement this push_back function we have two moves in the output instead
// of 4 copies... There will still be 2 copies since the realloc uses copy...
// We fix this by changing the ReAlloc function:

void ReAlloc(size_t newCapacity) {
	T* newBlock = new T[newCapacity];

	// Check if we're downsizing
	if (newCapacity < m_size)
		m_size = newCapacity;

	for(size_t = 0; i < m_size; i++){
		// newBlock[i] = m_data[i];
		// This is changed to move instead. We cast it to be an rvalue reference and try
		// and move it. If there's no move constructor for the type, it's going to copy it...
		//newBlock[i] = std::move(m_data[i]);

		// Bug where the newBlock[i] doesn't exist because the constructor isn't called,
		// the memory is just allocated with the T* newBlock new operator above...
		//newBlock[i] = std::move(m_data[i]);

		// FIX using placement new instead:
		// Basically the same thing but also calling the constructor...
		new (&newBlock[i]) T(std::move(m_data[i]));
	}

	delete[] m_data;

	m_data = newBlock;
	m_capacity = newCapacity;
}

// Now the output will only contain move!
// Very effective for strings etc, doesn't matter that much for the floats in Vector3, but
// it's the principle that matters...

// emplace_back is a special function in the std vector class which is really useful...
// Instead of constructing the Vector3 with Vector3(1.0f) etc in the stackframe of main
// and then moving it into that storage we have inside vector which is the case above, with
// emplace_back we instead provide the arguments that are needed to construct the Vector3 and
// it will do the contruction inplace in the data block...

// So we change this:
vector.push_back(Vector3(1.0f)); // Scalar
vector.push_back(Vector3(2,3,4); // x,y,z
vector.push_back(Vector3());
// To this:

vector.emplace_back(1.0f); // Scalar
vector.emplace_back(2,3,4; // x,y,z
vector.emplace_back();

// To make the emplace_back in our vector class we need variatic templates...
// We use T reference since we're constructing something in place
template<typename... Args>
T& emplace_back(Args&&... args)
{
	if (m_size >= m_capacity)
		ReAlloc(m_capacity + m_capacity / 2);

	// Forward all arguments to our constructor, the triple dots unpack the arguments...
	// Because we basically now want to say: all the variatic template arguments that
	// we've passed over in emplace_back() I want to expand them so that T gets the
	// correct argument.
	m_data[m_size] = T(std::forward<Args>(args)...);

	// Return and increment size since something new is added...
	return m_data[m_size++];
}

// In the output there will be some Destroys since we're releasing the old variables, the
old vector3 instances when we actually move them...

// We also of course need this:

~Vector()
{
	delete[] m_data;
}

// If we're holding actual pointers in the vector, we need to make sure that we delete
them... It's not the responsibility of the vector...
Vector<Vector3*> vector;

// If we wish to resize the Vector, we can add this to the vector class:

void PopBack()
{
	if(m_size > 0) {
		m_size--;
		m_data[m_size].~T(); // Explicitly call the destructor
		// The destructor call will nullify the object and release any resources that it
		// might own.
	}
}

// Clear function:
void Clear()
{
	for(size_t i = 0; i < m_size; i++)
		m_data[i].~T();

	m_size = 0;
}

// Now we can test it with lots of emplace_back, prints, pop_back, clear, emplaces etc...

// Advanced tip:
// We can also use "placement new" for constructing objects in place... 
template<typename... Args>
T& emplace_back(Args&&... args)
{
	if (m_size >= m_capacity)
		ReAlloc(m_capacity + m_capacity / 2);

	// we want to contruct the object in place of this actual memory: m_data[m_size]
	// m_data[m_size] = T(std::forward<Args>(args)...);

	// Instead of constructing this object on the stack in emplace_back and then moving it
	// into m_data storage, how about you just contruct it in m_data. So how do we
	// construct things in-place?
	// We use "placement new operator"
	new(&m_data[m_size]) T(std::forward<Args>(args)...);
	return m_data[m_size++];
}

// Now the output is extremely clean!

// There's a small bug however in the allocating and deallocating
// The delete[] call in the destructor and potentially manually calling destructor is
// risky. Lots of care is needed when calling destructors manually... Because the delete
// function might also call the destructor...
// The problem is demonstrated by having a memory block m_memoryBlock that is deleted in
// the ~Vector3 destructor and in the vector class...

----------------------------------------------------------------------------------
Final Vector class changes:

void ReAlloc(size_t newCapacity) {
	// We dont' need to use the constructor, we can use opeartor new again
	//T* newBlock = new T[newCapacity];
	T* newBlock (T*) ::operator new(newCapacity * sizeof(T));

	// Check if we're downsizing
	if (newCapacity < m_size)
		m_size = newCapacity;

	for(size_t = 0; i < m_size; i++){
		// newBlock[i] = m_data[i];
		// This is changed to move instead. We cast it to be an rvalue reference and try
		// and move it. If there's no move constructor for the type, it's going to copy it...

		// Bug where the newBlock[i] doesn't exist because the constructor isn't called,
		// the memory is just allocated with the T* newBlock new operator above...
		//newBlock[i] = std::move(m_data[i]);

		// FIX using placement new instead:
		// Basically the same thing but also calling the constructor...
		new (&newBlock[i]) T(std::move(m_data[i]));
	}

	// We don't call clear, to leave the size intact
	for(size_t i = 0; i < m_size; i++)
		m_data[i].~T();

	// We also use opeartor delete instead of delete
	//delete[] m_data;
	::operator delete(m_data, m_capacity * sizeof(T));

	m_data = newBlock;
	m_capacity = newCapacity;
}

// We also change the Vector destructor:
~Vector()
{
	::opeartor delete(m_data, m_capacity * sizeof(T)); // This won't call any destructors
	// Clear will call the destructors...
}


struct Vector3 {
	float x = 0.0f, y = 0.0f, z = 0.0f;
	// Used to allocate memory on the heap
	int* m_memoryBlock = nullptr;

	Vector3() { m_memoryBlock = new int[5]; // This needs to be deallocated}
	Vector3(float scalar) 
		: x(scalar), y(scalar), z(scalar) {
			m_memoryBlock = new int[5]; // This needs to be deallocated...
			}
	Vector3(float x, float y, float z) 
		: x(x), y(y), z(z) {
			m_memoryBlock = new int[5]; // This needs to be deallocated...
			}

	/**
	* To show that copy isn't being used, we delete the copy functions...
	Vector3(const Vector3& other)
		: x(other.xx), y(other.xy), z(other.z)
	{
		std::cout << "Copy\n";
	}
	*/
	Vector3(const Vector3& other) = delete;

	Vector3(const Vector3&& other) 
		: x(other.x), y(other.y), z(other.z)
	{
		// Skip this in the copy function since it's not being used right now
		m_memoryBlock = other.m_memoryBlock;
		other.m_memoryBlock = nullptr;
		std::cout << "Move\n";
	}

	~Vector3()
	{
		std::cout << "Destroy\n";
		// Deallocate memoryblock
		delete[] m_memoryBlock;
	}

	/**
	* To show that copy isn't being used, we delete the copy functions...
	// Move and assign operators
	Vector3& operator=(const Vector3& other)
	{
		std::cout << "Copy\n";
		x = other.x;
		y = other.y;
		z = other.z;
		return *this;
	}
	*/

	Vector3& operator=(const Vector3& other) = delete;

	Vector3& operator=(Vector3&& other)
	{
		std::cout << "Move\n";
		x = other.x;
		y = other.y;
		z = other.z;
		return *this;
	}
}

// Function to print the vector class with Vector3
template<>
void PrintVector(const Vector<Vector3>& vector)
{
	for(size_t i = 0; i < vector.Size(); i++){
		std::coud << vector[i].x << vector[i].y << vector[i].z << std::endl;
	}
	std::coud << "----------------------------\n";
}

int main()
{
	Vector<Vector> vector;

	vector.push_back(Vector3(1.0f)); // Scalar
	vector.push_back(Vector3(2,3,4); // x,y,z
	vector.push_back(Vector3());

	PrintVector(vector);
	// This should print something like:
}

--------------------------------------------
Vector iterator class!
template <typename Vector>
class VectorIterator
{
public:
	using ValueType = typename Vector::ValueType;
	using PointerType = ValueType*;
	using ReferenceType = ValueType&;

public:
	VectorIterator(PointerType ptr) : m_ptr(ptr) {}

	// Prefix operator
	// For other data structures, the iterator pattern is the same but with slight
	// changes. For example, if you're iterating through a graph you might need to change
	// the ++ operator to get the child element for example.
	VectorIterator& operator++()
	{
		// Modify object in-place
		m_ptr++;
		return *this;
	}

	// Post fix operator (differentiated by taking int as arg)
	VectorIterator operator++(int)
	{
		// Copy of the iterator
		VectorIterator iterator = *this;
		++(*this);
		return iterator;
	}

	// Prefix decrement operator
	VectorIterator& operator--()
	{
		// Modify object in-place
		m_ptr--;
		return *this;
	}

	// Post fix operator (differentiated by taking int as arg)
	VectorIterator operator--(int)
	{
		// Copy of the iterator
		VectorIterator iterator = *this;
		--(*this);
		return iterator;
	}

	// Index operator, returns reference
	ReferenceType operator[](int index)
	{
		return *(m_ptr + index);
	}

	// Arrow operator
	PointerType operator->()
	{
		return m_ptr;
	}

	// Derefenrece operator
	ReferenceType operator*()
	{
		return *m_ptr;
	}

	// Comparison operators
	bool operator==(const VectorIterator& other) const
	{
		return m_ptr == other.m_ptr;
	}

	bool operator!=(const VectorIterator& other) const
	{
		return !(*this == other);
	}

private:
	PointerType m_ptr;
};

// This needs to be added to the vector:
public:
	using ValueType T;
	using Iterator = VectorIterator<Vector<T>>;

	VectorIterator begin()
	{
		return Iterator(m_data);
	}

	VectorIterator end()
	{
		return Iterator(m_data + m_size);
	}


int main()
{
	// Test the VectorIterator and vector class
	Vector<std::string> values;
	values.emplace_back("Cherno");
	values.emplace_back("C++");
	values.emplace_back("Test");
	values.emplace_back("Jonas");

	std::cout << "not using iterators\n";
	for(int i = 0; i < values.Size(); i++){
		std::cout << values[i] << std::endl;
	}

	std::cout << "Range-based for loop\n";
	//for(int value : values){ // For int based vector
	for(auto& value : values){
		std::cout << value << std::endl;
	}

	std::cout << "Iterator\n";
	for(Vector<std::string>::Iterator it = values.begin(); it != values.end(); it++){
		std::cout << *it << std::endl;
	}
}

----------------------------------------------------------------------------------
PYTHON:
The *args and **kwargs is a common idiom to allow arbitrary number of arguments to
functions as described in the section more on defining functions in the Python
documentation.

The *args will give you all function parameters as a tuple:

def foo(*args):
    for a in args:
        print(a)        

foo(1)
# 1

foo(1,2,3)
# 1
# 2
# 3
The **kwargs will give you all keyword arguments except for those corresponding to a
formal parameter as a dictionary.

def bar(**kwargs):
    for a in kwargs:
        print(a, kwargs[a])  

bar(name='one', age=27)
# name one
# age 27
Both idioms can be mixed with normal arguments to allow a set of fixed and some variable
arguments:

def foo(kind, *args, **kwargs):
   pass
It is also possible to use this the other way around:

def foo(a, b, c):
    print(a, b, c)

obj = {'b':10, 'c':'lee'}

foo(100,**obj)
# 100 10 lee
Another usage of the *l idiom is to unpack argument lists when calling a function.

def foo(bar, lee):
    print(bar, lee)

l = [1,2]

foo(*l)
# 1 2
In Python 3 it is possible to use *l on the left side of an assignment (Extended Iterable
Unpacking), though it gives a list instead of a tuple in this context:

first, *rest = [1,2,3,4]
first, *l, last = [1,2,3,4]
Also Python 3 adds new semantic (refer PEP 3102):

def func(arg1, arg2, arg3, *, kwarg1, kwarg2):
    pass
For example the following works in python 3 but not python 2:

>>> x = [1, 2]
>>> [*x]
[1, 2]
>>> [*x, 3, 4]
[1, 2, 3, 4]

>>> x = {1:1, 2:2}
>>> x
{1: 1, 2: 2}
>>> {**x, 3:3, 4:4}
{1: 1, 2: 2, 3: 3, 4: 4}
Such function accepts only 3 positional arguments, and everything after * can only be
passed as keyword arguments.

Note:
A Python dict, semantically used for keyword argument passing, are arbitrarily ordered.
However, in Python 3.6, keyword arguments are guaranteed to remember insertion order.
"The order of elements in **kwargs now corresponds to the order in which keyword arguments
were passed to the function." - What’s New In Python 3.6
In fact, all dicts in CPython 3.6 will remember insertion order as an implementation
detail, this becomes standard in Python 3.7.

-------------------------------------------------
Map function and Lambda expression in Python to replace characters:

# Function to replace a character c1 with c2
# and c2 with c1 in a string S
 
def replaceChars(input,c1,c2):
 
     # create lambda to replace c1 with c2, c2
     # with c1 and other will remain same
     # expression will be like "lambda x:
     # x if (x!=c1 and x!=c2) else c1 if (x==c2) else c2"
     # and map it onto each character of string
     newChars = map(lambda x: x if (x!=c1 and x!=c2) else \
                c1 if (x==c2) else c2,input)
 
     # now join each character without space
     # to print resultant string
     print (''.join(newChars))
 
# Driver program
if __name__ == "__main__":
    input = 'grrksfoegrrks'
    c1 = 'e'
    c2 = 'r'
    replaceChars(input,c1,c2)
